# -*- coding: utf-8 -*-
"""Curvefiting.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1gJow6LiCFJIRgs_hTdv4WrQKPnE1B7OK
"""

import seaborn as sns
import time, math
import numpy as np 
import pandas as pd
import matplotlib.pyplot as plt
# %matplotlib inline
import datetime
from sklearn.model_selection import train_test_split
from sklearn.pipeline import make_pipeline
from sklearn.preprocessing import StandardScaler
from sklearn.svm import SVR
from sklearn.linear_model import LinearRegression, BayesianRidge
from sklearn.linear_model import Ridge
from sklearn.preprocessing import PolynomialFeatures
from sklearn.preprocessing import MinMaxScaler, StandardScaler

def Late_weighted_average(List,window,countries,forecast):
  for j in range(len(List)):
    for k in range(forecast):
      Sumlast10 = 0
      for i in range(len(List[j]),len(List[j])-window,-1):
        if ((len(List[j])-i)<2):
          Sumlast10 = Sumlast10 + 1.8*List[j][i-1]
        elif ((len(List[j])-i)<4):
          Sumlast10 = Sumlast10 + 1.4*List[j][i-1]
        elif ((len(List[j])-i)<6):
          Sumlast10 = Sumlast10 + 1*List[j][i-1]
        elif ((len(List[j])-i)<8):
          Sumlast10 = Sumlast10 + 0.5*List[j][i-1]
        else:
          Sumlast10 = Sumlast10 + 0.4*List[j][i-1]
      NextDayCases = Sumlast10/window
      List[j].append(round(NextDayCases))
    print(countries[j], "will have around", List[j][-10:], "the next ten days")

def Central_weighted_average(List,window,countries,forecast):
  for j in range(len(List)):
    for k in range(forecast):
      Sumlast10 = 0
      for i in range(len(List[j]),len(List[j])-window,-1):
        if ((len(List[j])-i)<2):
          Sumlast10 = Sumlast10 + 0.4*List[j][i-1]
        elif ((len(List[j])-i)<4):
          Sumlast10 = Sumlast10 + 1.2*List[j][i-1]
        elif ((len(List[j])-i)<6):
          Sumlast10 = Sumlast10 + 2*List[j][i-1]
        elif ((len(List[j])-i)<8):
          Sumlast10 = Sumlast10 + 1.2*List[j][i-1]
        else:
          Sumlast10 = Sumlast10 + 0.4*List[j][i-1]
      NextDayCases = Sumlast10/window
      List[j].append(round(NextDayCases))
    print(countries[j], "will have around", List[j][-10:], "the next ten days")

def Early_weighted_average(List,window,countries,forecast):
  for j in range(len(List)):
    for k in range(forecast):
      Sumlast10 = 0
      for i in range(len(List[j]),len(List[j])-window,-1):
        if ((len(List[j])-i)<2):
          Sumlast10 = Sumlast10 + 0.4*List[j][i-1]
        elif ((len(List[j])-i)<4):
          Sumlast10 = Sumlast10 + 0.5*List[j][i-1]
        elif ((len(List[j])-i)<6):
          Sumlast10 = Sumlast10 + 1*List[j][i-1]
        elif ((len(List[j])-i)<8):
          Sumlast10 = Sumlast10 + 1.4*List[j][i-1]
        else:
          Sumlast10 = Sumlast10 + 1.8*List[j][i-1]
      NextDayCases = Sumlast10/window
      List[j].append(round(NextDayCases))
    print(countries[j], "will have around", List[j][-10:], "the next ten days")

def MakeDays(date_list,days_in_future):
  Passed_days = []
  for i in range(len(date_list)):
    Passed_days.append(i)
  future_forcast = np.array([i for i in range(len(Passed_days)+days_in_future)]).reshape(-1, 1)
  adjusted_days = future_forcast[:-days_in_future]

  start = '2020-01-03'
  start_date = datetime.datetime.strptime(start, '%Y-%m-%d')
  future_reported = []
  for i in range(len(future_forcast)):
      future_reported.append((start_date + datetime.timedelta(days=i)).strftime('%Y-%m-%d'))

  return (Passed_days,future_forcast,adjusted_days,future_reported)


def TrainTestSplit(X,Y):
  X_train_confirmed, X_test_confirmed, y_train_confirmed, y_test_confirmed = train_test_split(X, Y, test_size=0.15, shuffle=False) 
  X = np.array(X).reshape(-1, 1)
  Y = np.array(Y).reshape(-1, 1)
  X_train_confirmed = np.array(X_train_confirmed).reshape(-1, 1)
  X_test_confirmed = np.array(X_test_confirmed).reshape(-1, 1)
  y_train_confirmed = np.array(y_train_confirmed).reshape(-1, 1)
  y_test_confirmed = np.array(y_test_confirmed).reshape(-1, 1)
  return (X,Y,X_train_confirmed,y_train_confirmed,X_test_confirmed,y_test_confirmed)

def plot_predictions(Real_cases,Predict_cases,Present_days,Future_days,color,string):
    plt.figure(figsize=(16,10))
    plt.plot(Present_days,Real_cases,color='blue')
    plt.plot(Future_days, Predict_cases, linestyle='dashed',color=color)
    plt.title("Numbrer of confirmed cases VS {}".format(string),size=25)
    plt.ylabel("Number of confirmed cases",size=15)
    plt.xlabel("Days passed since begging",size=15)
    plt.legend(['Confirmed Cases', string], fontsize=15)
    plt.xticks(size=10)
    plt.yticks(size=10)
    plt.grid(True)
    plt.show()

def test_predictor(X_train,y_train,X_test,y_test,predictor1,predictor2,string,flag):
  if (flag):
    predictor1.fit(X_train,y_train)
    test_pred = predictor1.predict(X_test)
  else:
    X_new_test = predictor1.fit_transform(X_test)
    test_pred = predictor2.predict(X_new_test)
  plt.plot(y_test)
  plt.plot(test_pred)
  plt.grid(True)
  plt.legend(['Real Cases',string])

def Show_prediction_by_day(future_days_reported,string,mypred,days_future):
  print(string,"for the next {} days (Total cases):".format(days_future))
  my_set = set (zip(future_days_reported[-10:], np.round(mypred[-10:])))
  my_set = sorted(my_set)
  for x in my_set: 
    print(x[0]+":",x[1])
  print("For the next {} days the New cases will be according to {}:".format(days_future,string))
  for i in range(10,0,-1):
    cases_today = mypred[-i] - mypred[-(i+1)]
    print(future_days_reported[-i] +":",  np.round(cases_today))

def CurvePredictor(X_all,Y_all,predictor1,predictor2,future_forcast,scaling):
  if (scaling==False):
    if (predictor2==None):
      predictor1.fit(X_all,Y_all)
      prediction = predictor1.predict(future_forcast)
    else:
      X_poly_present = predictor1.fit_transform(X_all)
      X_poly_future = predictor1.fit_transform(future_forcast)
      predictor2.fit(X_poly_present, Y_all)
      prediction = predictor2.predict(X_poly_future)
  else:
    sc_days = StandardScaler()
    sc_y = StandardScaler()
    scaled_days = sc_days.fit_transform(X_all)
    scaled_cases = sc_y.fit_transform(Y_all)
    xx = sc_days.transform(future_forcast)
    predictor1.fit(scaled_days,scaled_cases)
    prediction = sc_y.inverse_transform(predictor1.predict(xx))

  return (prediction)

